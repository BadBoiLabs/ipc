# Delorean Protocol

![](https://github.com/BadBoiLabs/Delorean-Protocol/blob/044cf492dab6f6c2bbc490a9e2dde65013a1cce8/Delorean-Docs/assets/logo.png?raw=true)

Programmable Encryption To-The-Future!

---

## Delorean Protocol

A Fendermint blockchain for encryption-to-the-future using Identity Based Encryption

- Decryption keys are generated by the network once some on-chain conditions are met

- Conditions can be written as Solidity contracts

- Key generation is coupled to BFT liveness guarantees

---

## Identity Based Encryption

- Allows encrypting data such that the decrption key is a chosen value

- We use the *tlock* scheme of Gailly et al.
    - The decryption key is an aggregate BLS signature from a set of signers over some tag
    
    - The key is not required to encrypt, only to decrypt

> "tlock: Practical Timelock Encryption from Threshold BLS" - Gailly, Melissaris and, Romailler 2023 - https://eprint.iacr.org/2023/189

---

## tlock

The tlock paper proposes using the signed block heights produced by DRAND to encrypt to the future.

- Keys will always be produced once the block heights are reached

- Limited in what it can do

---

Delorean Protocol:

- Uses a Fendermint + CometBFT consensus network to enforce validators sign chosen tags

- Includes a Solidity API for triggering tag signing


---

## Using Delorean

1. Define conditions
2. Encrypt data
3. Trigger conditions
4. Network generates decryption key
5. Decryption

---

<!-- .slide: style="font-size: 28px;" -->

## 1. Write Conditions Contract and Deploy

```solidity [8-16]
contract DeloreanDemo {

    uint256 constant FUNDING_GOAL = 88 fil;
    bytes32 constant MEMO = "some-string";

    error InsufficientFunds();

    function releaseKey() public returns (bool) {
        
        if (address(this).balance < FUNDING_GOAL ) {
            revert InsufficientFunds();
        }

        DeloreanAPI.enqueueTag(MEMO);
        return (true);
    }
}
```

---

## 2. Encrypt Data Offchain

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/044cf492dab6f6c2bbc490a9e2dde65013a1cce8/Delorean-Docs/diagrams/flow_2.excalidraw.svg)

---

## 3. Trigger Key Generation Conditions


![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/044cf492dab6f6c2bbc490a9e2dde65013a1cce8/Delorean-Docs/diagrams/flow_3.excalidraw.svg)

---

## 4.1 Validators Sign Tag

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/044cf492dab6f6c2bbc490a9e2dde65013a1cce8/Delorean-Docs/diagrams/flow_4.excalidraw.svg)

> 2/3 validators must sign tag or network will halt.
> Key generation is coupled to network liveness guarantees

---

## 4.2 Block Producer Aggregates Key

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/044cf492dab6f6c2bbc490a9e2dde65013a1cce8/Delorean-Docs/diagrams/flow_5.excalidraw.svg)

---

## 5. Decrypt

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/044cf492dab6f6c2bbc490a9e2dde65013a1cce8/Delorean-Docs/diagrams/flow_6.excalidraw.svg)

> Decryption key and message are public data
> Everyone can now decrypt

---

## Potential Applications

- Fund Raising
    - Key is generated once the contract raises some amount of funds
- Hush Money
    - Key is generated if the contract does not receive a periodic payment ðŸ˜ˆ
- Dead Man Switch
    - Key is generated the contract it doesn't receive a 'heartbeat' transaction from a preauthrized account for a number of blocks
