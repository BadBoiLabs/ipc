![](https://github.com/BadBoiLabs/Delorean-Protocol/blob/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/assets/banner.png?raw=true =1000x100)

![](https://github.com/BadBoiLabs/Delorean-Protocol/blob/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/assets/logo.png?raw=true =300x300)

Programmable Encryption To-The-Future!

---

## Encryption to the Future

Using blockchains and witness encryption it is possible to encrypt data such that the network will automatically generate the decryption keys at some point in the future

> "tlock: Practical Timelock Encryption from Threshold BLS" - Gailly, Melissaris and, Romailler 2023 - https://eprint.iacr.org/2023/189

---

### Application - Dead Person Switch

<!-- .slide: style="font-size: 28px;" -->

![](https://i2.wp.com/comments.bmartin.cc/wp-content/uploads/2014/09/In-case-of-whistleblower-break-glass.jpg)


- Imagine you are a whistleblower in possession of sensitive public-interest material
- You want decryption key to be released if you fail to make a scheduled check-in

> This is impossible using regular encryption-to-the-future


---

## Delorean Protocol

<!-- .slide: style="font-size: 30px;" -->


A IPC subnet for **programmable** encryption-to-the-future

- Decryption keys are generated by the network once some on-chain conditions are met

- Conditions can be written as Solidity contracts

- Key generation is coupled to BFT liveness guarantees

---

<!-- .slide: style="font-size: 20px;" -->

```solidity [9-13]
contract DeadSwitch {

    address constant OWNER = 0xabc...;
    uint constant CHECK_IN_FREQ = 100; // blocks
    bytes32 constant MEMO = "some-string";
    
    uint lastCheckIn;

    function checkIn() public {
        if (msg.sender == OWNER) {
            lastCheckIn = block.number
        }
    }
    
    function releaseKey() public returns (bool) {
        if (block.number < lastCheckIn + CHECK_IN_FREQ ) {
            revert;
        }
        DeloreanAPI.enqueueTag(MEMO);
        return (true);
    }
}
```

---

<!-- .slide: style="font-size: 20px;" -->

```solidity [15-21]
contract DeadSwitch {

    address constant OWNER = 0xabc...;
    uint constant CHECK_IN_FREQ = 100; // blocks
    bytes32 constant MEMO = "some-string";
    
    uint lastCheckIn;

    function checkIn() public {
        if (msg.sender == OWNER) {
            lastCheckIn = block.number
        }
    }
    
    function releaseKey() public returns (bool) {
        if (block.number < lastCheckIn + CHECK_IN_FREQ ) {
            revert;
        }
        DeloreanAPI.enqueueTag(MEMO);
        return (true);
    }
}
```

---

## Background - Witness Encryption

<!-- .slide: style="font-size: 28px;" -->

- Allows encrypting data such that the decrption key is the solution (witness) to some constraints

- We use the threshold BLS scheme of Gailly et al.
    - The decryption key is an aggregate BLS signature from a set of signers over some chosen string
    
    - The key is not required to encrypt, only to decrypt

> "tlock: Practical Timelock Encryption from Threshold BLS" - Gailly, Melissaris and, Romailler 2023 - https://eprint.iacr.org/2023/189

---

## Architecture

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/diagrams/arch.excalidraw.svg)

---

## Using Delorean

1. Define conditions
2. Encrypt data
3. Trigger conditions
4. Network generates decryption key
5. Decryption

---

<!-- .slide: style="font-size: 28px;" -->

## 1. Write Conditions Contract and Deploy

```solidity [8-16]
contract DeloreanDemo {

    uint256 constant FUNDING_GOAL = 88 fil;
    bytes32 constant MEMO = "some-string";

    error InsufficientFunds();

    function releaseKey() public returns (bool) {
        
        if (address(this).balance < FUNDING_GOAL ) {
            revert InsufficientFunds();
        }

        DeloreanAPI.enqueueTag(MEMO);
        return (true);
    }
}
```

---

## 2. Encrypt Data Offchain

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/diagrams/flow_2.excalidraw.svg)

---

## 3. Trigger Key Generation Conditions


![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/diagrams/flow_3.excalidraw.svg)

---

## 4.1 Validators Sign Tag

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/diagrams/flow_4.excalidraw.svg)

> 2/3 validators must cast valid votes or network halts
> Key generation is coupled to network liveness guarantees

---

## 4.2 Block Producer Aggregates Key

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/diagrams/flow_5.excalidraw.svg)

---

## 5. Decrypt

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/diagrams/flow_6.excalidraw.svg)

> Decryption key and message are public data
> Everyone can now decrypt

---

## Demo

![](https://raw.githubusercontent.com/BadBoiLabs/Delorean-Protocol/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/diagrams/demo.excalidraw.svg)

---

## Potential Applications

- Fund Raising
    - Key is generated once the contract raises some amount of funds
- Hush Money
    - If the contract does not receive a periodic payment the key can be generated ðŸ˜ˆ
- Dead Man Switch
    - Key is generated the contract it doesn't receive a 'heartbeat' transaction from a preauthrized account for a number of blocks

---

### Thanks

![](https://github.com/BadBoiLabs/Delorean-Protocol/blob/32deb847aa72e005493a6832c7f1d05e78f2ec19/Delorean-Docs/assets/logo.png?raw=true =400x400)

*"Where we're going, we don't need centralized key registries!"*
